title: Telefonspiel
enabled: false
count_score: no
difficulty: easy
ivr: true
--------
Programmiere dein eigenes Telefonspiel!

Wenn dein Spiel live geschaltet ist, kannst du es unter der Telefonnummer <b>030/75438953</b> (Ortstarif) spielen.
--------
[verify]
false
--------
[template]
class Game(AnswerPhone):
    def run(self):
        self.bg_play('C23E5grsczE')
        self.sleep(6000)
        self.say("Hallo und herzlich willkommen in der Hackschule.")
        self.sleep(2000)
        self.say("Leider können wir deinen Anruf momentan nicht persönlich entgegennehmen.")
        self.sleep(2000)
        self.say("Bitte gib deinen vierstelligen Code ein, um ein Spiel zu starten.")
        self.sleep(2000)
        self.say("Falls du keinen Code hast, kannst du auch ein zufälliges Spiel starten. Drücke dafür bitte einfach die 0.")
        self.hangup()
--------
[custom_main_pre]
import json
import subprocess
import sys
from importlib.machinery import SourceFileLoader

class AnswerPhone:
    def __init__(self, pipe):
        self.pipe = pipe
        self._reset()
        self.bg_tag = None
        self.ivr_mode = False
        if len(sys.argv) > 1 and sys.argv[1] == '--ivr':
            self.ivr_mode = True

    def _reset(self):
        self.voice_queue = []

    def _api_call(self, data):
        proc = subprocess.Popen(['curl', '-s', '-X', 'POST', 'http://tts_helper:9292/', '--data-binary', '@-'], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        proc.stdin.write(json.dumps(data).encode('utf-8'))
        proc.stdin.close()
        response = proc.stdout.read()
        response = json.loads(response)
        return response

    def _flush(self):
        data = {'command': 'mix', 'voice_queue': []}
        if self.bg_tag != None:
            data['bg_tag'] = self.bg_tag
        for path in self.voice_queue:
            data['voice_queue'].append(path)
        response = self._api_call(data)
        if self.ivr_mode:
            self.pipe.write(json.dumps({'path': response['path']}) + "\n")
        else:
            self.pipe.write(json.dumps({'path': response['path_hd']}) + "\n")
        self.pipe.flush()
        self._reset()

    def _dispatch(self, code):
        _global_dispatch('bdgy1kvx')

    def bg_play(self, tag):
        self.bg_tag = tag

    def bg_stop(self):
        self.bg_tag = None

    def say(self, text):
        first = True
        response = self._api_call({'command': 'say', 's': text})
        remaining = response['remaining']
        self.voice_queue.append(response['path_hd'])
        for sentence in remaining:
            response = self._api_call({'command': 'say', 's': sentence, 'already_split': True})
            self.voice_queue.append(response['path_hd'])

    def sleep(self, ms):
        response = self._api_call({'command': 'sleep', 'ms': ms})
        self.voice_queue.append(response['path_hd'])

    def dtmf(self, max_digits):
        self._flush()
        if self.ivr_mode:
            self.pipe.write(json.dumps({'get_dtmf': max_digits}) + "\n")
            self.pipe.flush()
            return sys.stdin.readline().strip()
        else:
            dtmf = input(f"Eingabe (max. {max_digits} Stellen): ")
            self.pipe.write(json.dumps({'command': 'reset_audio_queue'}) + "\n")
            self.pipe.flush()
            return dtmf

    def hangup(self):
        self.sleep(1000)
        self._flush()
        self.pipe.write(json.dumps({'command': 'hangup'}) + "\n")
        self.pipe.flush()
        if self.ivr_mode:
            while True:
                pass
            #sys.exit(0)
        else:
            while True:
                pass

def _global_dispatch(code):
    module = SourceFileLoader(code, f"/code/{code}.py").load_module()
    game = module.Game(sys.stdout)
    game.run()
    game.hangup()
