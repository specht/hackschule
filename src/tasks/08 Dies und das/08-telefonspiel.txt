title: Telefonspiel
enabled: false
count_score: no
difficulty: easy
ivr: true
--------
Programmiere dein eigenes Telefonspiel!

Wenn dein Spiel live geschaltet ist, kannst du es unter der folgenden Telefonnummer spielen:
<div style='font-size: 150%; border-radius: 8px; border: 1px solid rgba(0,0,0,0.5); padding: 10px; text-align: center;'>
<i class='fa fa-phone-square' style='color: #4aa03f;'></i>&nbsp;&nbsp;<a href='tel:+493075438953'>030/75438953</a>
<span style='opacity: 0.7; font-size: 70%;'>(Ortstarif)</span>
</div>
<div id='ivr_div_list'></div>
<div id='ivr_div'></div>
--------
[verify]
false
--------
[template]
class Game(AnswerPhone):
    def run(self):
        self.bg_play('https://youtu.be/dQsYLvGhO-k')
        self.sleep(4000)
        self.say("Hallo.")
        self.sleep(2000)
        self.say("Hier kannst du dein eigenes Telefonspiel machen.")
        self.sleep(2000)
        self.say("Du kannst dein Programm Texte sprechen lassen und Eingaben von der Tastatur des Telefons einlesen.")
        self.sleep(2000)
        self.say("Machen wir mal ein Beispiel. Drück bitte eine Taste.")
        # 20 Sekunden warten, damit die Hintergrundgeräusche
        # nicht sofort aufhören, wenn der gesprochene Text
        # vorbei ist und nur noch auf die Eingabe gewartet wird.
        self.sleep(20000)
        taste = self.dtmf(1)
        self.say(f"Danke. Du hast die Taste {taste} gedrückt.")
        self.sleep(2000)
        self.say("Das Programm wird nun beendet.")
--------
[custom_main_pre]
import json
import subprocess
import sys
import os
import tempfile

class AnswerPhone:
    def __init__(self, pipe):
        self.pipe = pipe
        self._reset()
        self.bg_tag = None
        self.ivr_mode = False
        if len(sys.argv) > 1 and sys.argv[1] == '--ivr':
            self.ivr_mode = True

    def _reset(self):
        self.voice_queue = []

    def _api_call(self, data):
        proc = subprocess.Popen(['curl', '-s', '-X', 'POST', 'http://tts_helper:9292/', '--data-binary', '@-'], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        proc.stdin.write(json.dumps(data).encode('utf-8'))
        proc.stdin.close()
        response = proc.stdout.read()
        response = json.loads(response)
        return response

    def _flush(self):
        data = {'command': 'mix', 'voice_queue': []}
        if self.bg_tag != None:
            data['bg_tag'] = self.bg_tag
        for path in self.voice_queue:
            data['voice_queue'].append(path)
        response = self._api_call(data)
        if self.ivr_mode:
            self.pipe.write(json.dumps({'path': response['path']}) + "\n")
        else:
            self.pipe.write(json.dumps({'path': response['path_hd']}) + "\n")
        self.pipe.flush()
        self._reset()

    def _dispatch(self, code):
        _global_dispatch('bdgy1kvx')

    def bg_play(self, tag):
        self.bg_tag = tag

    def bg_stop(self):
        self.bg_tag = None

    def say(self, text):
        first = True
        response = self._api_call({'command': 'say', 's': text})
        remaining = response['remaining']
        self.voice_queue.append(response['path_hd'])
        for sentence in remaining:
            response = self._api_call({'command': 'say', 's': sentence, 'already_split': True})
            self.voice_queue.append(response['path_hd'])

    def sleep(self, ms):
        response = self._api_call({'command': 'sleep', 'ms': ms})
        self.voice_queue.append(response['path_hd'])

    def dtmf(self, max_digits):
        self._flush()
        if self.ivr_mode:
            self.pipe.write(json.dumps({'get_dtmf': max_digits}) + "\n")
            self.pipe.flush()
            return sys.stdin.readline().strip()
        else:
            dtmf = input(f"Eingabe (max. {max_digits} Stellen): ")
            self.pipe.write(json.dumps({'command': 'reset_audio_queue'}) + "\n")
            self.pipe.flush()
            return dtmf

    def hangup(self):
        self.sleep(1000)
        self._flush()
        self.pipe.write(json.dumps({'command': 'hangup'}) + "\n")
        self.pipe.flush()
        if self.ivr_mode:
            while True:
                pass
            #sys.exit(0)
        else:
            while True:
                pass

def _global_dispatch(code):
    print("_global_dispatch:", code, file = sys.stderr)
    with tempfile.NamedTemporaryFile() as temp:
        with open(f'/ivr/header.py') as f:
            temp.write(f.read().encode('utf-8'))
        temp.write("\n".encode('utf-8'))
        with open(f'/code/{code}.py') as f:
            temp.write(f.read().encode('utf-8'))
        temp.write("\n".encode('utf-8'))
        temp.write("game = Game(sys.stdout)\n".encode('utf-8'))
        temp.write("game.run()\n".encode('utf-8'))
        temp.write("game.hangup()\n".encode('utf-8'))
        temp.flush()
        os.execv('/usr/bin/python3', ['/usr/bin/python3', temp.name, '--ivr'])
